---
phase: 02-search-duplicate-detection
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - midl-agent/src/search/search-cache.ts
autonomous: true

must_haves:
  truths:
    - "Repeated searches for the same terms return cached results without hitting GitHub API"
    - "Cache entries expire after a configurable TTL"
    - "Cache is keyed by normalized search terms (order-independent)"
  artifacts:
    - path: "midl-agent/src/search/search-cache.ts"
      provides: "In-memory TTL cache for search results"
      exports: ["SearchCache"]
  key_links:
    - from: "midl-agent/src/search/search-cache.ts"
      to: "midl-agent/src/types/search-types.ts"
      via: "imports GitHubIssueResult for cached values"
      pattern: "GitHubIssueResult"
---

<objective>
Build a standalone in-memory cache for GitHub search results with TTL expiration and normalized keys.

Purpose: Reduce API calls (critical for unauthenticated 60 req/hr mode) and speed up repeated searches.
Output: SearchCache class ready to be wired into IssueSearcher in Plan 03.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@midl-agent/src/types/search-types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: SearchCache with TTL and normalized keys</name>
  <files>midl-agent/src/search/search-cache.ts</files>
  <action>
    Create search-cache.ts with a SearchCache class:

    - Constructor: `constructor(options?: { ttlMs?: number, maxEntries?: number })`
      - Default TTL: 5 minutes (300_000 ms)
      - Default max entries: 100

    - Internal storage: `Map<string, { results: GitHubIssueResult[], timestamp: number }>`

    - Method: `normalizeKey(terms: string[]): string`
      - Sort terms alphabetically, lowercase, join with "|"
      - This means "error typescript" and "typescript error" hit the same cache entry

    - Method: `get(terms: string[]): GitHubIssueResult[] | null`
      - Normalize key
      - If entry exists and not expired (Date.now() - timestamp < ttlMs): return results
      - If expired: delete entry, return null
      - If not found: return null

    - Method: `set(terms: string[], results: GitHubIssueResult[]): void`
      - Normalize key
      - If at maxEntries: evict oldest entry (by timestamp)
      - Store results with current timestamp

    - Method: `clear(): void` -- flush all entries

    - Method: `size(): number` -- return current entry count

    Keep it simple: plain Map, no external dependencies. This is an in-memory cache
    that resets when the process restarts. That is fine for a CLI agent.
  </action>
  <verify>Run `cd midl-agent && npx tsc --noEmit` -- compiles cleanly.</verify>
  <done>SearchCache class exists with get/set/clear/normalizeKey methods, TTL expiration, and LRU-style eviction at max capacity.</done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for SearchCache</name>
  <files>midl-agent/src/search/search-cache.test.ts</files>
  <action>
    Create search-cache.test.ts with vitest tests:

    1. "returns null for cache miss"
    2. "returns cached results for cache hit"
    3. "normalizes key order (typescript error == error typescript)"
    4. "returns null for expired entries" -- use a short TTL (50ms), set, wait 60ms, get should return null
    5. "evicts oldest entry when at max capacity" -- create cache with maxEntries: 2, add 3 entries, first should be evicted
    6. "clear() removes all entries"

    Use fake GitHubIssueResult objects (just need number, title, url -- other fields can be minimal stubs).

    For the TTL test, use a real setTimeout/delay (50ms is fast enough for tests).
  </action>
  <verify>Run `cd midl-agent && npx vitest run` -- all tests pass including new cache tests.</verify>
  <done>6 tests covering cache hit, miss, TTL expiration, key normalization, eviction, and clear.</done>
</task>

</tasks>

<verification>
- `cd midl-agent && npx tsc --noEmit` compiles with zero errors
- `cd midl-agent && npx vitest run` all tests pass
- SearchCache normalizes keys so term order does not matter
- Expired entries are not returned
</verification>

<success_criteria>
- INTEG-05: Cache exists and prevents duplicate API calls for same search terms
- Cache TTL works (expired entries return null)
- Cache key normalization works (order-independent)
- All 6+ unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-search-duplicate-detection/02-02-SUMMARY.md`
</output>
