---
phase: 02-search-duplicate-detection
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - midl-agent/src/search/similarity-scorer.ts
  - midl-agent/src/search/duplicate-detector.ts
  - midl-agent/src/search/issue-searcher.ts
autonomous: true

must_haves:
  truths:
    - "Each search result has a similarity score between 0 and 1"
    - "Issues scoring above 0.75 are flagged as likely duplicates"
    - "Agent displays top results with scores and duplicate flags"
    - "IssueSearcher uses cache to avoid redundant API calls"
  artifacts:
    - path: "midl-agent/src/search/similarity-scorer.ts"
      provides: "Calculates similarity between user description and issue"
      exports: ["SimilarityScorer"]
    - path: "midl-agent/src/search/duplicate-detector.ts"
      provides: "Orchestrates full pipeline: search + score + flag duplicates"
      exports: ["DuplicateDetector", "DuplicateDetectionResult"]
  key_links:
    - from: "midl-agent/src/search/duplicate-detector.ts"
      to: "midl-agent/src/search/issue-searcher.ts"
      via: "calls search() to get raw results"
      pattern: "searcher\\.search"
    - from: "midl-agent/src/search/duplicate-detector.ts"
      to: "midl-agent/src/search/similarity-scorer.ts"
      via: "calls score() on each result"
      pattern: "scorer\\.score"
    - from: "midl-agent/src/search/issue-searcher.ts"
      to: "midl-agent/src/search/search-cache.ts"
      via: "checks cache before API call"
      pattern: "cache\\.get|cache\\.set"
---

<objective>
Build similarity scoring, duplicate detection, and wire the cache into the search pipeline. This completes the full search-and-detect flow.

Purpose: Users see scored results with duplicate flags before creating a report.
Output: DuplicateDetector class that is the single entry point for the entire Phase 2 feature.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-search-duplicate-detection/02-01-SUMMARY.md
@.planning/phases/02-search-duplicate-detection/02-02-SUMMARY.md
@midl-agent/src/search/issue-searcher.ts
@midl-agent/src/search/search-cache.ts
@midl-agent/src/types/search-types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: SimilarityScorer and DuplicateDetector</name>
  <files>midl-agent/src/search/similarity-scorer.ts, midl-agent/src/search/duplicate-detector.ts, midl-agent/src/types/search-types.ts</files>
  <action>
    1. Add types to search-types.ts:
       ```typescript
       export interface DuplicateDetectionResult {
         results: SearchResult[];        // sorted by similarityScore descending
         duplicates: SearchResult[];     // results with score >= threshold
         hasDuplicates: boolean;
         searchTerms: string[];          // terms that were used
       }
       ```

    2. Create similarity-scorer.ts with SimilarityScorer class:
       - Method: `score(description: string, issue: GitHubIssueResult): number`
       - Algorithm (simple, NOT ML):
         a. Tokenize both description and (issue.title + " " + issue.body) into lowercase words
         b. Remove stop words from both (reuse the same stop word list as term-extractor, extract it to a shared constant in a new file or just duplicate -- prefer shared)
         c. Calculate Jaccard similarity: |intersection| / |union| of the two word sets
         d. Apply a title boost: if any description word appears in the issue title, add 0.15 to the score (capped at 1.0). Title matches are stronger signals.
         e. Return score clamped to [0, 1]
       - This is intentionally simple. Jaccard + title boost gives reasonable results for keyword overlap without any ML.

    3. Create duplicate-detector.ts with DuplicateDetector class:
       - Constructor: `{ searcher?: IssueSearcher, scorer?: SimilarityScorer, threshold?: number }`
         - Default threshold: 0.75
         - If no searcher provided, create default IssueSearcher
         - If no scorer provided, create default SimilarityScorer
       - Method: `async detect(description: string, options?: SearchOptions): Promise<DuplicateDetectionResult>`
         a. Call searcher.search(description, options) to get raw results
         b. For each result, call scorer.score(description, result.issue) and set result.similarityScore
         c. Sort results by similarityScore descending
         d. Filter duplicates: results where similarityScore >= threshold
         e. Return { results, duplicates, hasDuplicates: duplicates.length > 0, searchTerms }
       - Method: `formatResults(result: DuplicateDetectionResult): string`
         - Returns a human-readable string for the agent to display:
           ```
           Found 5 related issues:

           [DUPLICATE] #123 (92% match) - Error when calling sign function
             https://github.com/midl-xyz/midl-js/issues/123

           #456 (45% match) - TypeScript compilation issue
             https://github.com/midl-xyz/midl-js/issues/456
           ...
           ```
         - Issues above threshold get "[DUPLICATE]" prefix
         - Score displayed as percentage (Math.round(score * 100))

    4. Wire cache into IssueSearcher (modify issue-searcher.ts):
       - Add SearchCache to constructor DI: `{ client?, extractor?, cache?: SearchCache }`
       - If no cache provided, create default SearchCache
       - In search() method:
         a. After extracting terms, check cache.get(terms)
         b. If cache hit: return cached results (skip GitHub API call entirely)
         c. If cache miss: call GitHub API, then cache.set(terms, results) before returning
  </action>
  <verify>Run `cd midl-agent && npx tsc --noEmit` -- compiles cleanly.</verify>
  <done>SimilarityScorer calculates Jaccard + title boost scores. DuplicateDetector orchestrates full pipeline. IssueSearcher uses cache. All TypeScript compiles.</done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for scorer and detector</name>
  <files>midl-agent/src/search/similarity-scorer.test.ts, midl-agent/src/search/duplicate-detector.test.ts</files>
  <action>
    1. Create similarity-scorer.test.ts:
       - "scores identical text as 1.0 (or near 1.0)"
       - "scores completely different text as 0 (or near 0)"
       - "title match boosts score" -- description "typescript error" vs issue with title "typescript error in build" should score higher than issue with same words only in body
       - "score is between 0 and 1 inclusive"
       - Use simple test fixtures, no mocking needed (pure function)

    2. Create duplicate-detector.test.ts:
       - Mock IssueSearcher to return known issues (DI pattern)
       - Mock SimilarityScorer to return controlled scores (DI pattern)
       - "flags results above threshold as duplicates"
       - "returns hasDuplicates: true when duplicates exist"
       - "returns hasDuplicates: false when no duplicates"
       - "sorts results by score descending"
       - "formatResults includes [DUPLICATE] prefix for high-score issues"
       - "formatResults shows percentage scores"

    Use the DI constructor pattern to inject mocked dependencies. No real GitHub calls.
  </action>
  <verify>Run `cd midl-agent && npx vitest run` -- all tests pass (old and new).</verify>
  <done>Scorer tests verify Jaccard algorithm behavior. Detector tests verify threshold logic, sorting, and formatting. All tests green.</done>
</task>

</tasks>

<verification>
- `cd midl-agent && npx tsc --noEmit` compiles with zero errors
- `cd midl-agent && npx vitest run` all tests pass
- DuplicateDetector.detect() returns scored, sorted results with duplicate flags
- IssueSearcher uses cache (second call for same terms does not hit GitHub)
- formatResults() produces readable output with [DUPLICATE] prefix and percentages
</verification>

<success_criteria>
- SEARCH-05: Each result has a similarity score on 0-1 scale (Jaccard + title boost)
- SEARCH-06: Results above 0.75 threshold flagged as duplicates
- SEARCH-07: DuplicateDetector flags high-confidence duplicates before report creation
- INTEG-05: Cache integrated into IssueSearcher, prevents redundant API calls
- Full pipeline works: description -> terms -> search -> score -> flag -> format
</success_criteria>

<output>
After completion, create `.planning/phases/02-search-duplicate-detection/02-03-SUMMARY.md`
</output>
