---
phase: 03-solution-extraction-user-flow
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - midl-agent/src/search/search-config.ts
  - midl-agent/src/search/bug-report-generator.ts
  - midl-agent/src/search/issue-creator.ts
  - midl-agent/src/search/github-client.ts
autonomous: true

must_haves:
  truths:
    - "Search behavior is configurable via a config file (thresholds, result limits)"
    - "Agent auto-generates bug reports from conversation context without interview-style Q&A"
    - "Agent creates GitHub issues automatically for non-duplicates after user confirmation"
    - "Agent falls back to manual submission link when token lacks write permissions"
  artifacts:
    - path: "midl-agent/src/search/search-config.ts"
      provides: "SearchConfig loader with defaults and file override"
      exports: ["loadSearchConfig", "DEFAULT_SEARCH_CONFIG"]
    - path: "midl-agent/src/search/bug-report-generator.ts"
      provides: "BugReportGenerator that drafts reports from conversation context"
      exports: ["BugReportGenerator"]
    - path: "midl-agent/src/search/issue-creator.ts"
      provides: "IssueCreator that creates GitHub issues or falls back to manual link"
      exports: ["IssueCreator"]
  key_links:
    - from: "midl-agent/src/search/issue-creator.ts"
      to: "GitHubClient.createIssue"
      via: "POST /repos/{owner}/{repo}/issues"
      pattern: "createIssue"
    - from: "midl-agent/src/search/bug-report-generator.ts"
      to: "IssueCreator"
      via: "passes formatted report for submission"
      pattern: "IssueCreator"
---

<objective>
Build search configuration, context-aware bug report generation, and automatic GitHub issue creation.

Purpose: This plan delivers the infrastructure for the user-facing flow. Config makes the agent tunable. BugReportGenerator replaces the old interview workflow with context-aware drafting. IssueCreator closes the loop by submitting issues to GitHub. Covers INTEG-04, SEARCH-11, SEARCH-12, and Decision 7 from CONTEXT.md.

Output: SearchConfig loader, BugReportGenerator class, IssueCreator class, createIssue method on GitHubClient.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@midl-agent/src/search/github-client.ts
@midl-agent/src/types/search-types.ts
@.planning/phases/03-solution-extraction-user-flow/03-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: SearchConfig loader and createIssue API method</name>
  <files>midl-agent/src/search/search-config.ts, midl-agent/src/search/github-client.ts</files>
  <action>
**SearchConfig loader** (`search-config.ts`):

Create a module that:
1. Exports `DEFAULT_SEARCH_CONFIG` with sensible defaults:
   - duplicateThreshold: 0.75
   - maxResults: 5
   - searchTimeoutMs: 5000
   - cacheTtlMs: 300000 (5 minutes)
   - applicabilityWeights: { errorMessage: 0.40, sdkVersion: 0.20, network: 0.15, methodName: 0.15, confirmedFix: 0.10 }
2. Exports `loadSearchConfig(configPath?: string): SearchConfig`
   - If configPath provided and file exists, reads JSON, merges with defaults (deep merge for nested objects)
   - If no configPath or file missing, returns defaults
   - Logs warning if file exists but can't be parsed
   - Uses `fs.readFileSync` (config loaded once at startup, sync is fine)
3. Import `SearchConfig` type from search-types.ts (added by plan 03-01, but type is defined there -- if 03-01 hasn't run yet, add the type here with a note)

**IMPORTANT:** Plan 03-01 adds the `SearchConfig` interface to search-types.ts. If executing in parallel and the type doesn't exist yet, define it locally in search-config.ts and export it. The orchestrator will reconcile.

**createIssue on GitHubClient** (`github-client.ts`):

Add method:
```typescript
async createIssue(title: string, body: string, labels?: string[]): Promise<{ number: number; url: string }> {
  await this.checkRateLimit();
  try {
    const response = await this.octokit.rest.issues.create({
      owner: this.owner,
      repo: this.repo,
      title,
      body,
      labels: labels ?? [],
    });
    return {
      number: response.data.number,
      url: response.data.html_url,
    };
  } catch (error) {
    throw this.handleApiError(error);
  }
}
```
  </action>
  <verify>TypeScript compiles: `cd midl-agent && npx tsc --noEmit`</verify>
  <done>SearchConfig loads from file with defaults fallback. GitHubClient.createIssue posts new issues to GitHub API.</done>
</task>

<task type="auto">
  <name>Task 2: BugReportGenerator and IssueCreator</name>
  <files>midl-agent/src/search/bug-report-generator.ts, midl-agent/src/search/issue-creator.ts</files>
  <action>
**BugReportGenerator** (`bug-report-generator.ts`):

Context-aware bug report generator that replaces the interview-style workflow (Decision 1, 3 from CONTEXT.md).

```typescript
export interface BugReportDraft {
  title: string;
  description: string;
  stepsToReproduce: string;
  expectedBehavior: string;
  actualBehavior: string;
  environment: {
    sdkVersion?: string;
    nodeVersion?: string;
    browser?: string;
    os?: string;
    network?: string;
  };
  errorOutput?: string;
  severity: "critical" | "high" | "medium" | "low";
}

export class BugReportGenerator {
  /**
   * Generate a bug report draft from conversation context.
   * Extracts: error messages, SDK versions, network, method names,
   * steps/reproduction info from the user's natural language description.
   *
   * This replaces the 4-phase interview workflow. The agent does the work.
   */
  generate(userDescription: string, additionalContext?: Partial<BugReportDraft>): BugReportDraft {
    // Extract error message: look for quoted strings, stack traces, "Error:" patterns
    // Extract SDK version: @midl/react X.Y.Z, @midl/core X.Y.Z patterns
    // Extract network: testnet, mainnet, signet, regtest
    // Extract method names: camelCase function calls
    // Generate title: first sentence or error summary, max 80 chars
    // Set severity heuristic: "crash" / "data loss" = critical, "error" = high, "unexpected" = medium, else low
    // Merge with additionalContext (user edits override extracted values)
  }

  formatAsMarkdown(draft: BugReportDraft): string {
    // Format as GitHub issue markdown matching the existing bug report template structure:
    // ## Description, ## Steps to Reproduce, ## Expected vs Actual, ## Environment, ## Error Output
  }

  formatAsGitHubLink(draft: BugReportDraft, owner: string, repo: string): string {
    // Returns https://github.com/{owner}/{repo}/issues/new?title=...&body=...
    // URL-encode title and body for manual submission fallback
  }
}
```

Keep extraction logic simple -- regex-based, no ML (per deferred ideas). The agent's LLM will do the heavy semantic lifting; this class handles structured extraction.

**IssueCreator** (`issue-creator.ts`):

Handles GitHub issue creation with graceful degradation (Decision 7 from CONTEXT.md).

```typescript
export interface IssueCreationResult {
  created: boolean;
  issueNumber?: number;
  issueUrl?: string;
  fallbackUrl?: string; // manual submission link if creation failed
  error?: string;
}

export class IssueCreator {
  private client: GitHubClient;
  private reportGenerator: BugReportGenerator;

  constructor(deps?: { client?: GitHubClient; reportGenerator?: BugReportGenerator }) {
    this.client = deps?.client ?? new GitHubClient({ token: process.env.GITHUB_TOKEN });
    this.reportGenerator = deps?.reportGenerator ?? new BugReportGenerator();
  }

  async createFromDraft(draft: BugReportDraft, labels?: string[]): Promise<IssueCreationResult> {
    const body = this.reportGenerator.formatAsMarkdown(draft);
    try {
      const result = await this.client.createIssue(draft.title, body, labels);
      return { created: true, issueNumber: result.number, issueUrl: result.url };
    } catch (error) {
      // Graceful degradation: return manual link on auth/permission failure
      const fallbackUrl = this.reportGenerator.formatAsGitHubLink(draft, this.client.owner, this.client.repo);
      return {
        created: false,
        fallbackUrl,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }
}
```

Constructor DI pattern consistent with codebase. Graceful degradation: if token lacks write permissions, returns manual submission URL instead of failing.
  </action>
  <verify>TypeScript compiles: `cd midl-agent && npx tsc --noEmit`</verify>
  <done>BugReportGenerator extracts context and formats reports. IssueCreator creates GitHub issues with fallback to manual submission link on auth failure.</done>
</task>

</tasks>

<verification>
```bash
cd midl-agent && npx tsc --noEmit
```
TypeScript compiles cleanly. All new classes export properly.
</verification>

<success_criteria>
- SearchConfig loads from JSON file with sensible defaults
- BugReportGenerator extracts error messages, SDK versions, network from natural language
- BugReportGenerator formats reports as GitHub markdown and as pre-filled issue URLs
- IssueCreator creates issues via API or falls back to manual link
- GitHubClient.createIssue calls POST /repos/{owner}/{repo}/issues
- All classes use constructor DI pattern
</success_criteria>

<output>
After completion, create `.planning/phases/03-solution-extraction-user-flow/03-02-SUMMARY.md`
</output>
