---
phase: 03-solution-extraction-user-flow
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - midl-agent/src/search/workflow-orchestrator.ts
  - midl-agent/src/search/fix-implementer.ts
  - midl-agent/system-prompt.md
  - midl-agent/bug-report-workflow.md
autonomous: true

must_haves:
  truths:
    - "Agent presents solutions to user before creating a bug report"
    - "User is prompted to check existing issue or create a new report (clear decision point)"
    - "User can proceed with new report if existing solutions don't help"
    - "Existing bug report workflow works identically to before when no search results are relevant"
    - "Search-first approach is the default flow for all bug reports"
    - "Agent can locate relevant code and apply a fix when user says 'Yes, implement it'"
    - "Agent shows diff before writing changes and explains WHY the fix works"
  artifacts:
    - path: "midl-agent/src/search/workflow-orchestrator.ts"
      provides: "WorkflowOrchestrator tying search, extraction, scoring, reporting, and fix implementation together"
      exports: ["WorkflowOrchestrator", "WorkflowResult"]
    - path: "midl-agent/src/search/fix-implementer.ts"
      provides: "FixImplementer that locates code and applies single-point fixes from solutions"
      exports: ["FixImplementer", "FixResult"]
    - path: "midl-agent/system-prompt.md"
      provides: "Updated system prompt with search-first bug report and implementation assistance instructions"
      contains: "search-first"
    - path: "midl-agent/bug-report-workflow.md"
      provides: "Replaced interview workflow with context-aware flow"
      contains: "WorkflowOrchestrator"
  key_links:
    - from: "midl-agent/src/search/workflow-orchestrator.ts"
      to: "DuplicateDetector.detect"
      via: "search-first: finds duplicates before report creation"
      pattern: "duplicateDetector.detect"
    - from: "midl-agent/src/search/workflow-orchestrator.ts"
      to: "SolutionExtractor.extract"
      via: "extracts solutions from top matching issues"
      pattern: "solutionExtractor.extract"
    - from: "midl-agent/src/search/workflow-orchestrator.ts"
      to: "BugReportGenerator.generate"
      via: "auto-drafts report when no solutions help"
      pattern: "reportGenerator.generate"
    - from: "midl-agent/src/search/workflow-orchestrator.ts"
      to: "FixImplementer.implementFix"
      via: "applies solution fix to user's code when requested"
      pattern: "fixImplementer.implementFix"
    - from: "midl-agent/system-prompt.md"
      to: "WorkflowOrchestrator"
      via: "instructs agent to use search-first flow with implementation assistance"
      pattern: "WorkflowOrchestrator"
---

<objective>
Wire all Phase 3 components into a single workflow orchestrator and update agent instructions to use the new search-first, context-aware bug report flow.

Purpose: This is the integration plan that makes everything user-facing. The orchestrator is the single entry point the agent calls when a user reports a problem. System prompt and workflow docs tell the agent how to use it. Covers SEARCH-10, INTEG-01, INTEG-02, and Decisions 1-6 from CONTEXT.md.

Output: WorkflowOrchestrator class, updated system-prompt.md, replaced bug-report-workflow.md.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-solution-extraction-user-flow/03-01-SUMMARY.md
@.planning/phases/03-solution-extraction-user-flow/03-02-SUMMARY.md
@.planning/phases/03-solution-extraction-user-flow/03-CONTEXT.md
@midl-agent/src/search/duplicate-detector.ts
@midl-agent/src/search/solution-extractor.ts
@midl-agent/src/search/applicability-scorer.ts
@midl-agent/src/search/bug-report-generator.ts
@midl-agent/src/search/issue-creator.ts
@midl-agent/src/search/search-config.ts
@midl-agent/system-prompt.md
@midl-agent/bug-report-workflow.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: WorkflowOrchestrator</name>
  <files>midl-agent/src/search/workflow-orchestrator.ts</files>
  <action>
Create the main orchestrator that ties all Phase 2 and Phase 3 components together. This is the single entry point the agent uses when a user reports a problem.

```typescript
export interface WorkflowResult {
  // Phase: Search
  searchPerformed: boolean;
  duplicatesFound: DuplicateDetectionResult | null;

  // Phase: Solutions
  solutions: ApplicabilityResult[];
  hasSolutions: boolean;

  // Phase: Report (only if user proceeds past solutions)
  reportDraft: BugReportDraft | null;

  // Formatted output for the agent to present
  formattedResponse: string;
}

export class WorkflowOrchestrator {
  private duplicateDetector: DuplicateDetector;
  private solutionExtractor: SolutionExtractor;
  private applicabilityScorer: ApplicabilityScorer;
  private reportGenerator: BugReportGenerator;
  private issueCreator: IssueCreator;
  private fixImplementer: FixImplementer;
  private config: SearchConfig;

  constructor(deps?: { ... }) // Constructor DI for all dependencies

  /**
   * Main entry point: user describes a problem.
   * 1. Search for duplicates (Phase 2 DuplicateDetector)
   * 2. For top matches, fetch comments and extract solutions
   * 3. Score solution applicability against user's context
   * 4. Return formatted response with solutions or report draft
   */
  async handleProblemReport(
    userDescription: string,
    userContext?: Partial<UserContext>
  ): Promise<WorkflowResult>

  /**
   * Called when user decides to create a report (no solution helped).
   * Generates draft from conversation context, offers for review.
   */
  generateReportDraft(
    userDescription: string,
    additionalContext?: Partial<BugReportDraft>
  ): BugReportDraft

  /**
   * Called when user approves the report draft.
   * Creates GitHub issue or returns manual link.
   */
  async submitReport(draft: BugReportDraft, labels?: string[]): Promise<IssueCreationResult>

  /**
   * Format solutions for agent to present to user.
   * Follows the conversational tone from CONTEXT.md Decision 4.
   * Example: "I found issue #456 that matches your problem (87% similar)..."
   */
  private formatSolutionsResponse(solutions: ApplicabilityResult[], duplicates: DuplicateDetectionResult): string

  /**
   * Format report draft for user review.
   * Shows the draft and asks "Does this look right? (yes/edit/add more)"
   */
  private formatReportDraftResponse(draft: BugReportDraft): string

  /**
   * Called when user says "Yes, implement it" (Decision 5).
   * Delegates to FixImplementer to locate code, apply fix, and return diff.
   * Only proceeds with explicit user consent.
   */
  async implementSolution(
    solution: ApplicabilityResult,
    projectRoot: string
  ): Promise<FixResult>
}
```

**Flow logic in handleProblemReport:**
1. Build UserContext from userDescription + userContext param
2. Call `duplicateDetector.detect(userDescription)`
3. If results found, for top 3 results with comments > 0:
   - Fetch comments via GitHubClient.getIssueComments
   - Extract solutions via SolutionExtractor.extract
   - Score each solution via ApplicabilityScorer.scoreApplicability
4. Filter to solutions with level != "probably not relevant"
5. Sort by score descending
6. If solutions found: format as conversational response (Decision 4 style)
7. If no solutions: auto-generate report draft, format for review
8. Return WorkflowResult with all data

**Formatting guidelines (from CONTEXT.md Decisions 4, 5, 6):**
- Conversational, not robotic
- Explain root cause, fix, and WHY it applies
- Offer clear options: "Want me to implement this fix?" → calls implementSolution() / "Show me how" → shows code example / "That's not my issue" → proceeds to report
- If no solutions: "Here's a draft bug report from our conversation: ... Does this look right?"
- Keep it to 1-2 user interactions
  </action>
  <verify>TypeScript compiles: `cd midl-agent && npx tsc --noEmit`</verify>
  <done>WorkflowOrchestrator.handleProblemReport() performs search-first flow, extracts and scores solutions, formats conversational response. implementSolution() delegates to FixImplementer for code modification. generateReportDraft() and submitReport() handle the bug report path.</done>
</task>

<task type="auto">
  <name>Task 2: Update system prompt and bug report workflow</name>
  <files>midl-agent/system-prompt.md, midl-agent/bug-report-workflow.md</files>
  <action>
**Update system-prompt.md:**

Replace section "### 4. **Bug Reporting Assistance**" with a new section that instructs the agent to use the search-first workflow:

```markdown
### 4. **Bug Reporting & Solution Search**
When a user reports an issue or describes a problem:
1. **Search First**: Use WorkflowOrchestrator.handleProblemReport() to search GitHub for existing solutions
2. **Present Solutions**: If solutions found, explain the root cause, the fix, and why it applies to the user's context
3. **Offer Options**:
   - "Want me to implement this fix?" → Find code, apply fix, show diff
   - "Show me how" → Provide code example
   - "That's not my issue" → Proceed to bug report
4. **Auto-Generate Report**: If no solutions help, draft a bug report from conversation context (no interview Q&A)
5. **User Reviews**: Show draft: "Does this look right? (yes/edit/add more)"
6. **Submit**: Create GitHub issue automatically, or provide manual link if token lacks write permissions
7. **Return URL**: Give user the direct link to created issue

**Key principle**: The agent does the work. Extract info from conversation context. Target 1-2 user interactions, not 15+ questions.
```

**Replace bug-report-workflow.md:**

Replace the entire interview-style workflow (Phase 1-4 questions) with the new context-aware workflow that documents:
1. How the agent uses WorkflowOrchestrator
2. The search-first flow (search → solutions → report if needed)
3. Context extraction (what the agent looks for in conversation)
4. Bug report template structure (keep: title, description, reproduction, environment, error output)
5. Category-specific guidance (keep: SDK issues, transaction failures, React hooks, type safety)
6. Severity levels (keep: Critical, High, Medium, Low)
7. How to use IssueCreator for submission vs manual link fallback

Preserve the bug report template structure and category guidance from the existing file. Replace only the interactive Q&A phases with context-aware extraction.

**Important:** The existing bug report template markdown format (title, description, steps, expected vs actual, environment, error output) must be preserved -- BugReportGenerator outputs this same format. Only the GATHERING method changes (context extraction vs interview).
  </action>
  <verify>Read both files and confirm: system-prompt.md mentions search-first workflow, bug-report-workflow.md no longer has interview-style Phase 1-4 questions</verify>
  <done>System prompt instructs agent to use search-first WorkflowOrchestrator with implementation assistance. Bug report workflow replaces interview Q&A with context-aware extraction while preserving report template and category guidance.</done>
</task>

<task type="auto">
  <name>Task 3: FixImplementer -- code location and modification capability (Decision 5)</name>
  <files>midl-agent/src/search/fix-implementer.ts</files>
  <action>
Create FixImplementer that implements Decision 5 (Implementation Assistance). This is the component that locates relevant code in the user's project and applies fixes from verified GitHub issue solutions.

```typescript
export interface FixResult {
  applied: boolean;
  filePath?: string;
  diff?: string;          // before/after diff shown to user
  explanation?: string;   // WHY the change works
  error?: string;
}

export class FixImplementer {
  constructor(deps?: { fs?: typeof import('fs') }) // DI for testability

  /**
   * Locate relevant code in user's project and apply a fix from a solution.
   *
   * Scope: Single-point fixes only (1-2 line changes, single file).
   * Multi-file refactoring is OUT OF SCOPE (deferred idea).
   *
   * Flow:
   * 1. Parse solution.codeSnippet for identifiers (method names, imports, config keys)
   * 2. Search projectRoot for files containing those identifiers (glob + grep)
   * 3. If exactly one match: read file, compute diff, return for user review
   * 4. If multiple matches: return list for user to pick
   * 5. If no matches: return error with guidance
   *
   * IMPORTANT: Does NOT write to disk. Returns the diff for user confirmation.
   * The agent writes the file only after user says "yes" to the diff.
   */
  async locateAndPrepareFix(
    solution: Solution,
    projectRoot: string
  ): Promise<FixResult>

  /**
   * Apply a previously prepared fix (after user confirmation).
   * Writes the modified content to disk.
   */
  async applyFix(
    filePath: string,
    newContent: string
  ): Promise<{ success: boolean; error?: string }>

  /**
   * Search project files for identifiers from the solution.
   * Uses simple glob + string matching (no AST parsing for v1).
   */
  private async findRelevantFiles(
    identifiers: string[],
    projectRoot: string
  ): Promise<string[]>

  /**
   * Generate a human-readable diff between old and new content.
   */
  private generateDiff(oldContent: string, newContent: string, filePath: string): string
}
```

**Scope constraints (from deferred ideas):**
- Only single-file, 1-2 line changes
- Only fixes from verified GitHub issues (solution.confidence === "confirmed" preferred)
- Only with explicit user consent (diff shown first, user confirms)
- No AST parsing, no multi-file refactoring
- Simple text-based search and replace

**Safety:**
- Never write without user confirmation
- Show before/after diff
- Explain WHY the change works (from solution.description)
- If fix can't be located, explain what to look for manually
  </action>
  <verify>TypeScript compiles: `cd midl-agent && npx tsc --noEmit`</verify>
  <done>FixImplementer.locateAndPrepareFix() finds relevant code and computes diff. applyFix() writes changes after user confirmation. Scope limited to single-file, 1-2 line fixes. Never writes without user consent.</done>
</task>

</tasks>

<verification>
```bash
cd midl-agent && npx tsc --noEmit
```
TypeScript compiles. System prompt references WorkflowOrchestrator. Bug report workflow no longer contains interview-style phases.
</verification>

<success_criteria>
- WorkflowOrchestrator is the single entry point for problem reports
- Search-first flow: search → extract solutions → score applicability → present OR draft report
- FixImplementer locates code and prepares diffs for user-approved fixes (Decision 5)
- WorkflowOrchestrator.implementSolution() wires FixImplementer to the solution presentation flow
- System prompt instructs agent to use new workflow including implementation assistance options
- Bug report workflow replaced with context-aware flow
- Existing report template structure preserved
- 1-2 user interactions target maintained
- Conversational tone per CONTEXT.md decisions
- Fix scope limited to single-file, 1-2 line changes (no multi-file refactoring)
</success_criteria>

<output>
After completion, create `.planning/phases/03-solution-extraction-user-flow/03-03-SUMMARY.md`
</output>
