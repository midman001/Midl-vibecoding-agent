---
phase: 03-solution-extraction-user-flow
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - midl-agent/src/search/github-client.ts
  - midl-agent/src/search/solution-extractor.ts
  - midl-agent/src/search/solution-extractor.test.ts
  - midl-agent/src/search/applicability-scorer.ts
  - midl-agent/src/search/applicability-scorer.test.ts
  - midl-agent/src/types/search-types.ts
autonomous: true

must_haves:
  truths:
    - "Agent extracts solutions and workarounds from GitHub issue comments"
    - "Agent assesses whether a solution applies to the user's specific context"
    - "Agent distinguishes positive solutions from failed attempts in comments"
  artifacts:
    - path: "midl-agent/src/search/solution-extractor.ts"
      provides: "SolutionExtractor class parsing issue comments for fixes/workarounds"
      exports: ["SolutionExtractor"]
    - path: "midl-agent/src/search/applicability-scorer.ts"
      provides: "ApplicabilityScorer with weighted confidence scoring"
      exports: ["ApplicabilityScorer"]
    - path: "midl-agent/src/types/search-types.ts"
      provides: "Solution, Workaround, ApplicabilityResult types"
      contains: "interface Solution"
  key_links:
    - from: "midl-agent/src/search/solution-extractor.ts"
      to: "GitHubClient.getIssueComments"
      via: "fetches comments for solution parsing"
      pattern: "getIssueComments"
    - from: "midl-agent/src/search/applicability-scorer.ts"
      to: "Solution type"
      via: "scores extracted solutions against user context"
      pattern: "scoreApplicability"
---

<objective>
Extract solutions from GitHub issue discussions and assess their applicability to the user's problem.

Purpose: This is the intelligence layer that transforms raw GitHub issues into actionable solutions. Without it, the agent just shows links -- with it, the agent explains root causes and offers fixes. Covers SEARCH-08, SEARCH-09.

Output: SolutionExtractor class, ApplicabilityScorer class, getIssueComments on GitHubClient, supporting types.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@midl-agent/src/search/github-client.ts
@midl-agent/src/types/search-types.ts
@midl-agent/src/search/duplicate-detector.ts
@.planning/phases/03-solution-extraction-user-flow/03-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add types and getIssueComments to GitHubClient</name>
  <files>midl-agent/src/types/search-types.ts, midl-agent/src/search/github-client.ts</files>
  <action>
Add these types to search-types.ts:

```typescript
export interface IssueComment {
  id: number;
  author: string;
  body: string;
  createdAt: string;
  isAuthor: boolean; // comment author === issue author
  reactions: { totalCount: number; plusOne: number; heart: number };
}

export interface Solution {
  type: "fix" | "workaround" | "config-change";
  description: string;
  codeSnippet?: string;
  sourceComment: IssueComment;
  confidence: "confirmed" | "suggested"; // confirmed = maintainer or positive reactions
  context: {
    sdkVersion?: string;
    network?: string;
    methodName?: string;
    errorMessage?: string;
  };
}

export interface ApplicabilityResult {
  solution: Solution;
  score: number; // 0-1
  level: "very likely" | "might help" | "probably not relevant";
  reasons: string[]; // why this score
}

export interface UserContext {
  errorMessage?: string;
  sdkVersion?: string;
  network?: string;
  methodName?: string;
  description: string;
}

export interface SearchConfig {
  duplicateThreshold: number;
  maxResults: number;
  searchTimeoutMs: number;
  cacheTtlMs: number;
  applicabilityWeights: {
    errorMessage: number;
    sdkVersion: number;
    network: number;
    methodName: number;
    confirmedFix: number;
  };
}
```

Add `getIssueComments` method to GitHubClient:

```typescript
async getIssueComments(issueNumber: number): Promise<IssueComment[]> {
  await this.checkRateLimit();
  try {
    const response = await this.octokit.rest.issues.listComments({
      owner: this.owner,
      repo: this.repo,
      issue_number: issueNumber,
      per_page: 50,
    });
    return response.data.map(comment => ({
      id: comment.id,
      author: comment.user?.login ?? "unknown",
      body: comment.body ?? "",
      createdAt: comment.created_at,
      isAuthor: false, // caller sets this by comparing to issue author
      reactions: {
        totalCount: (comment as any).reactions?.total_count ?? 0,
        plusOne: (comment as any).reactions?.["+1"] ?? 0,
        heart: (comment as any).reactions?.heart ?? 0,
      },
    }));
  } catch (error) {
    throw this.handleApiError(error);
  }
}
```

Note: `handleApiError` is currently private. Keep it private and add the method inside the class body.
  </action>
  <verify>TypeScript compiles: `cd midl-agent && npx tsc --noEmit`</verify>
  <done>search-types.ts exports Solution, IssueComment, ApplicabilityResult, UserContext, SearchConfig types. GitHubClient.getIssueComments fetches paginated comments with reaction data.</done>
</task>

<task type="auto">
  <name>Task 2: TDD SolutionExtractor</name>
  <files>midl-agent/src/search/solution-extractor.ts, midl-agent/src/search/solution-extractor.test.ts</files>
  <action>
TDD: Write tests first, then implement.

**SolutionExtractor** parses issue comments to find solutions and workarounds.

**Behavior to test:**
1. `extract(issue, comments)` returns `Solution[]`
2. Identifies code blocks in comments as potential fixes
3. Detects positive signals: "this worked", "fixed", "resolved", reactions > 0
4. Detects negative signals: "didn't work", "still broken", "same issue"
5. Extracts context from code/text: SDK version patterns (`@midl/react 1.x.x`, `v1.x`), network mentions (`testnet`, `mainnet`), method names (`broadcastTransaction`, etc.)
6. Comments from issue author with "this worked" are highest confidence
7. Returns empty array when no solutions found
8. Handles issues with no comments gracefully

**Implementation approach:**
- Constructor DI pattern (consistent with codebase): `constructor(deps?: { ... })`
- Parse each comment body:
  - Look for code blocks (triple backtick)
  - Look for positive/negative signal keywords
  - Skip negative-signal comments
  - Extract context via regex: version patterns, network keywords, method names
- Classify as "fix" (code change), "workaround" (alternative approach), or "config-change"
- Mark confidence as "confirmed" if: maintainer comment, or comment has reactions.plusOne >= 2, or contains "this worked"/"fixed it"
- Mark confidence as "suggested" otherwise

RED: Write failing tests. GREEN: Implement to pass. REFACTOR if needed.
  </action>
  <verify>`cd midl-agent && npx vitest run src/search/solution-extractor.test.ts` passes</verify>
  <done>SolutionExtractor.extract() parses comments, identifies solutions with confidence levels, extracts context metadata, and filters out failed attempts.</done>
</task>

<task type="auto">
  <name>Task 3: TDD ApplicabilityScorer</name>
  <files>midl-agent/src/search/applicability-scorer.ts, midl-agent/src/search/applicability-scorer.test.ts</files>
  <action>
TDD: Write tests first, then implement.

**ApplicabilityScorer** scores how well a Solution applies to the user's context.

**Behavior to test:**
1. `scoreApplicability(solution, userContext)` returns `ApplicabilityResult`
2. Exact error message match adds +0.40
3. Same SDK version adds +0.20
4. Same network adds +0.15
5. Same method name adds +0.15
6. Confirmed fix adds +0.10
7. Score >= 0.6 = "very likely", 0.3-0.6 = "might help", < 0.3 = "probably not relevant"
8. Reasons array explains each match/mismatch
9. Partial error message match (substring) adds +0.20 (half of exact)
10. Missing context fields don't penalize (no negative scores)

**Implementation approach:**
- Constructor DI: `constructor(deps?: { weights?: Partial<SearchConfig["applicabilityWeights"]> })`
- Default weights from CONTEXT.md: errorMessage=0.40, sdkVersion=0.20, network=0.15, methodName=0.15, confirmedFix=0.10
- Compare solution.context fields to userContext fields
- Build reasons array with human-readable explanations
- Clamp score to [0, 1]
- Map score to level string

RED: Write failing tests. GREEN: Implement to pass. REFACTOR if needed.
  </action>
  <verify>`cd midl-agent && npx vitest run src/search/applicability-scorer.test.ts` passes</verify>
  <done>ApplicabilityScorer.scoreApplicability() returns scored result with level ("very likely"/"might help"/"probably not relevant") and human-readable reasons array.</done>
</task>

</tasks>

<verification>
```bash
cd midl-agent && npx tsc --noEmit && npx vitest run src/search/solution-extractor.test.ts src/search/applicability-scorer.test.ts
```
All tests pass. TypeScript compiles cleanly.
</verification>

<success_criteria>
- SolutionExtractor extracts solutions from issue comments with confidence levels
- ApplicabilityScorer scores solutions against user context with weighted criteria
- GitHubClient.getIssueComments fetches issue discussion comments
- All new types exported from search-types.ts
- Tests cover positive/negative signal detection, scoring thresholds, edge cases
</success_criteria>

<output>
After completion, create `.planning/phases/03-solution-extraction-user-flow/03-01-SUMMARY.md`
</output>
